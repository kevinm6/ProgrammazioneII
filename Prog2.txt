Programmazione II
Marco Pasini
March 2021

Contents
1 Introduzione
1.1 Info . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.2 Astrazione . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.3 Struttura dei programmi . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.4 Packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.5 Variabili . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.6 Invocazione dei metodi . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.7 Hello World! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

3
3
3
3
4
4
4
4

2 Lezione 2
2.1 Controllo dei tipi . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.2 Gerarchia dei tipi . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.3 Conversioni e Overloading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4 Dispatching . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

5
5
5
5
6

3 Lezione 3
3.1 Tipi pirmitivi . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.2 Boxing - Unboxing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.3 Collezioni . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.4 Input - Output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.5 Argomenti da linea di comando . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

7
7
7
7
7
8

4 Lezione 4 - Astrazione procedurale
4.1 UtilitaÌ€ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.2 Comâ€™eÌ€ fatta la specificazione? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.2.1 Clausola Requires (o precondizione) . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.2.2 Clausola Effects (o postcondizione) . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.2.3 Clausola Modifies (o effetti collaterali) . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.3 Implementazione . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.4 Come si progetta e valuta una buona astrazione procedurale . . . . . . . . . . . . . . . . . . .

9
9
9
10
10
10
10
10

5 Eccezioni
12
5.1 Tipologie di eccezioni . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
5.2 Definire eccezioni . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
5.3 Gestire eccezioni . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
5.4 Programmare con le eccezioni . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
6 Lezione 6 - Astrazione sui dati
15
6.1 Specificazione per i tipi di dati . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
6.2 Metodi . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
6.3 IntSet . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
6.4 Poly . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
1

7 Lezione 7 - Metodi aggiungitivi
17
7.1 Distinzione di due oggetti con equals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
7.2 hashCode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
7.3 Rapporto tra rappresentazione ed astrazione . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
7.3.1 Funzione di astrazione (AF) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
7.3.2 Invariante di rappresentazione (RI) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
7.4 MutabilitaÌ€ ed effetti collaterali . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
8 Lezione 8 - Verifica mantenimento astrazione
23
8.1 Preservamento RI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
8.2 Correttezza delle operazioni . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
8.3 Preservazione degli AI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
8.4 MutabilitaÌ€ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
8.5 Adeguatezza . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
8.6 LocalitaÌ€ e modificabilitaÌ€ nellâ€™astrazione dei dati . . . . . . . . . . . . . . . . . . . . . . . . . . 24
9 Astrazione iterazione
25
9.1 Come viene specificata lâ€™iterazione? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
9.2 Nested class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
9.3 Implementazione in IntSet . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
9.4 Classi anonime . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
9.5 Generatori Standalone . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
9.6 Caching . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
10 EreditarietaÌ€
29
10.1 Dispatching . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
10.2 Come si implementano i tipi nella gerarchia? . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
10.3 IR e AF nella gerarchia . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
10.3.1 Esempio . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
11 Sottotipi
31
11.1 Regola dei metodi e specificazioni . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
12 Polimorfismo

31

13 Generici
31
13.1 Collezioni . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
13.2 Interfacce . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
14 Laboratorio

33

15 Metodi utili
34
15.1 Esercitazione 6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
15.1.1 Memoria . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
15.1.2 Registri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
15.1.3 VM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
15.1.4 ModalitaÌ€ di accesso . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
15.1.5 Opcode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37

2

1

Introduzione

1.1

Info

Per fare piccoli â€esperimentiâ€ con java senza creare un nuovo file ogni volta eÌ€ possibile invocare
JSHELL da terminale
Il corso non tratta il linguaggio di programmazione Java, bensÄ±Ì€ la metodologia di sviluppo di sistemi
SW, che possono avere dimensioni non indifferenti, eÌ€ importante avere programmi affidabili ed efficienti
in cui il sistema deve essere descritto in modo semplice per permettere la comprensione, la modifica e la
manutenzione.
Java eÌ€ un WORM (Write Once Run Many) che ha risolto il problema della portabilitaÌ€ tra diversi sistemi
operativi grazie al compilatore JAVAC che traduce il file sorgente .java in un bytecode .class. La
macchina virtuale viene invocata con il comando java, che esegue il bytecode eseguendo quindi il codice.
La chiave eÌ€ la modularizzazione, suddividendo il problema in sottoproblemi piuÌ€ piccoli e piuÌ€ semplici da
risolvere. I sotto-problemi (o moduli) devono
â€¢ Avere lo stesso livello di dettaglio
â€¢ Essere tutti indipendenti
â€¢ Essere componibili

1.2

Astrazione

Per modularizzare si utilizza lâ€™astrazione, che permette una maggiore comprensione di unâ€™entitaÌ€ mediante la
riduzione del dettaglio, separando gli aspetti rilevanti da quelli irrilevanti.
Astrazione per parametrizzazione: i dati vengono astratti e sono sostituiti con dei parametri generalizzando la procedura per poterla applicare su moltissimi valori
Astrazione per specificazione: se vengono rispettate certe condizioni iniziali (precondizioni ), allora il programma garantisce di fornire un oggetto che soddisfa determinate proprietaÌ€ (postcondizioni ). Ad esempio,
se fornisco un intero positivo, il programma mi restituiraÌ€ la sua radice.

1.3

Struttura dei programmi

Java eÌ€ orientato agli oggetti (una collezione di informazioni), che contengono:
â€¢ Stati: informazioni, possono essere:
1. Mutabili: negli stati mutabili devo porre attenzione ai metodi che invoco su di essi, infatti potrebbero modificarlo, dato che Java passa sempre gli oggetti per riferimento
2. Immutabili: come le stringhe. Quando accodo due stringhe, ne viene creata una terza il cui stato
eÌ€ la concatenazione degli stati delle prime due.
â€¢ Metodi: consentono di modificare o osservare lo stato
Le classi fanno â€vivereâ€ lâ€™oggetto e vengono utilizzate per la definire una collezione di procedure o di
nuovi tipi. Una classe definisce quindi un metodo per ogni procedura.
Tanti metodi â†’ classe
. Lâ€™intestazione o prototipo di un metodo eÌ€ il seguente:
int somma (int x, int y)
{z
}
|

Parametri formali

3

1.4

Packages

Java eÌ€ organizzato secondo una gerarchia. I pacchetti permettono di risolvere due problemi:
1. Incapsulamento: permette allâ€™utente di accedere ai metodi senza peroÌ€ accedere (ad esempio) direttamente al codice. Per questo motivo ogni classe ha una certa visibilitaÌ€.
2. Naming: permette di fare riferimento ad una classe allâ€™interno di un pacchetto indicando solamente il
metodo allâ€™interno di quel pacchetto. Se si vuole utilizzare un metodo di un altro pacchetto si deve
indicare il fully qualified name, cioeÌ€ il percorso specifico a partire dalla radice del file system. Per
evitare di utilizzare il fully qualified name eÌ€ possibile utilizzare import.

1.5

Variabili

Le. Sono indicate da:
1. Nome
2. Tipo:
â€¢ Primitivi: int, float, bool, etc.... Sono variabili locali che esistono allâ€™interno del metodo, quindi
vengono allocate nello stack, quando il metodo termina la variabile viene rimossa dallo stack
â€¢ Riferimento agli oggetti: array e oggetti, sono allocati dinamicamente nello heap e devono essere
inizializzate prima di utilizzarle, altrimenti il compilatore daraÌ€ errore. Possono sorgere dei problemi nel momento in cui faccio un assegnamento s=r quando gli stati sono mutabili, infatti al
modificare r modifico anche s. In Java gli oggetti e i vettori vengono automaticamente inizializzati a NULL, mentre gli interi viengono inzializzati a 0.
Quando non eÌ€ piuÌ€ presente un riferimento per degli oggetti allocati, il garbage collector si occupa
della loro eliminazione.

1.6

Invocazione dei metodi

Per invocare un metodo:
oggetto
| {z }

.nome

espressione riferimento

(arg1 , arg2 )
{z
}
|

parametri concreti (o attuali)

I parametri concerti vengono passati per valore ai parametri formali (1.3), quindi NON viene fatta la
copia.

1.7

Hello World!

java.lang eÌ€ il pacchetto prediletto ed eÌ€ automaticamente disponibile allâ€™interno del codice.
1
2
3
4
5
6
7
8

public class HelloWorld{
public static void main(String [] args{
int x, y;
x=1;
y=3;
System.out.println("Risultato: " +(x+y));
}
}

4

2

Lezione 2

2.1

Controllo dei tipi

Java eÌ€ un linguaggio fortemente tipato, cioÌ€ significa che il compilatore controlla il tipo di ogni assegnamento.
Il controllo dei tipi avviene in:
â€¢ Letterali, cioeÌ€ quando scrivo 3 Java capisce che eÌ€ un int, cosÄ±Ì€ come quando scrivo "Pippo" capisce
che eÌ€ String.
â€¢ Dichiarazione di variabili, quando scrivo String s
â€¢ Segnatura dei metodi, che consente di capire il tipo del codominio (valore restituito) e il dominio
â€¢ Mettendo insieme i punti precedenti si determina il tipo delle espressioni grazie allâ€™induzione strutturale

2.2

Gerarchia dei tipi

I tipi vivono in una gerarchia in cui ci puoÌ€ essere un sottotipo a e un supertipo b, che verraÌ€ cosÄ±Ì€ indicato
a â‰º b. La gerarchia gode della proprietaÌ€ transitiva e in testa alla gerarchia câ€™eÌ€ il tipo Object.
La relazione di sottotipo â‰º deve godere del Principio di sostituzione di Liskov:
â€¢ se a â‰º b, a deve avere tutti i metodi di b, quindi in qualsiasi punto del codice posso sostituire unâ€™istanza
di a con unâ€™istanza di b â†’ a extends b. Questa eÌ€ una proprietaÌ€ sintattica che viene controllata dal
compilatore
â€¢ Devono avere lo â€stessoâ€ comportamento e preservare la semantica.
Il principio di sostituzione, se a â‰º b, permette di scrivere b=a, dato che ad un supertipo eÌ€ sempre possibile
assegnare un sottotipo, dato che questâ€™ultimo eÌ€ piuÌ€ specializzato (a eÌ€ piuÌ€ speciale di b). Il controllo del tipo
avviene in due momenti:
1. In fase di compilazione: il tipo apparente (formale) viene dedotto dal compilatore dalle informazioni
presenti nelle sue dichiarazioni. Questo permette ai programmi Java che vegnono compilati di essere
type safe. La type safety eÌ€ garantita da tre meccanismi
â€¢ compile-time checking
â€¢ automatic storage management
â€¢ array bounds checking, rende impossibile accedere allâ€™indice 6 se lâ€™array ha solo 3 elementi
2. In fase di esecuzione: il tipo concreto eÌ€ il tipo che riceve al momento della sua creazione e puoÌ€ essere
diverso dal tipo apparente
Il tipo apparente vale per tutte le espressioni e per tutte le sottoespressioni. Ad esempio, in
((B)a).l(...,...):
((B)a).l(...,...) â†’ Tipo apparente di a = A
((B)a).l(...,...) â†’ Tipo apparente di ((B)a) = B
((B)a).l(...,...) â†’ Tipo apparente di ((B)a).l() = T (assumento che il metodo restituisca un
tipo T)

2.3

Conversioni e Overloading

La conversione implicita avviene nei tipi primitivi, ad esempio un char puoÌ€ essere esteso a tipi numerici.
Lâ€™overloading consiste in un sovraccaricamento che puoÌ€ riguardare:
â€¢ il nome degli operatori, ad esempio + viene utilizzato sia come operatore per la somma, sia per concatenare due stringhe

5

â€¢ la segnatura, quindi eÌ€ possibile avere due metodi con lo stesso nome ma con tipi differenti. Quando
ci sono piuÌ€ metodi con lo stesso nome il compilatore invoca il metodo piuÌ€ specifico, ovvero quello che
puoÌ€ essere invocato con l numero minore di conversioni implicite possibili. Quando il compilatore non
eÌ€ in grado di determinare il metodo piuÌ€ specifico (cioeÌ€ quando eÌ€ necessario fare lo stesso numero di
conversioni implicite) restituiraÌ€ un errore.

2.4

Dispatching

Come spiegato precedentemente, in fase di compilazione viene determinato il tipo apparente e per questo
motivo potrebbe chiamare un altro metodo (a causa dellâ€™overloading(?)) che ha un comportamento differente
rispetto a quello che ci si aspetta. Il dispatching dinamico interviene proprio per risolvere questo problema,
a run-time la JVM assegneraÌ€ il metodo in base al tipo concreto.
nel casting indico al compilatore che il tipo apparente eÌ€ diverso, quindi il dispatching deve essere fatto a
partire da b e non da a:
9
10
11
12
13

((B)a).l(...,...);
boolean equals (Object other);
String toString();
s==t; //in questo modo indica che s e t hanno lo stesso identico oggetto nello heap
s.equals(t); //equals indica se il contenuto di due oggetti
uguale

6

3

Lezione 3

3.1

Tipi pirmitivi

I tipi primitivi non sono dei riferimenti, quindi non sono oggetti e dato che puoÌ€ essere comodo invocare
metodi su di essi si eÌ€ introdotto il wrapping in cui, a ciascun primitivo, viene associato un tipo oggetto:
â€¢ costruttore new T(x)
â€¢ metodo statico T.valueof(x), che costruisce lâ€™oggetto del tipo primitivo
Per fare lâ€™inverso, quindi per passare da un oggetto ad un tipo primitivo si utilizza x=i.intValue().

3.2

Boxing - Unboxing

Si tratta di un metodo piuÌ€ moderno rispetto al creare oggetti nei due metodi precedenti in cui il compilatore
si rende conto automaticamente che in quella porzione di codice eÌ€ necessario un oggetto anzicheÌ€ un tipo
primitivo (e viceversa) ed esegue automaticamente il wrapping:
14
15
16

Integer i = ...;
4+i; //il compilatore esegue automaticamente il wrapping
//ed esegue 4+i.intValue

3.3

Collezioni

Le collezioni sono delle raccolte di oggetti omogenei e si differenziano dagli array dato che per questâ€™ultimi
la dimensione deve essere nota al momento della compilazione. Si sono introdotti i vector, anche se seguono
due problemi:
â€¢ Lâ€™api eÌ€ deprecato, il che significa che non eÌ€ consigliabile utilizzarlo dato che potrebbero essere eliminati
in futuro
â€¢ il Vector eÌ€ una collezione di Object, quindi eÌ€ molto generale ed eÌ€ necessario fare attenzione che nel
vector ci siano effettivamente oggetti omogenei. Inoltre, essendo il tipo apparente sempre un object
era sempre necessario fare il casting
Per questi motivi sono stati introdotti i generici e al posto dei generici sono state introdotte le liste:
// (interfaccia) permette di definire una collezione di stringhe
List <String> l;
//(implementazione) permette di inserire un oggetto nella collezione
List <String> l = new ArrayList<>();

17
18
19
20

3.4

Input - Output

Output: system.out.println(...)
Per lâ€™input formattato si utilizza lo scanner, una classe che ha la competenza di leggere un flusso e restituire
dei valori di tipo opportuno:
â€¢ Per istanziare lo scanner: s = new Scanner(System.in)
â€¢ Per consumarlo utilizzo lâ€™iteratore:
â€“ s.hasNextT() â†’ return bool
â€“ s.NextT() â†’ return t. Nel caso della lettura delle stringe s.Next() restituisce ogni volta
una nuova stringa, quindi se faccio un ciclo nello heap ci saranno molte stringhe, ma solamente
lâ€™ultima ha un riferimento.

7

3.5

Argomenti da linea di comando

Quando metto dei comandi dopo il comando java nel terminale, java riempie automaticamente lâ€™array
args. Se si tratta di stringhe peroÌ€, il comando
21

System.out.println(args);

da problemi, infatti rappresenta lâ€™array come viene â€rappresentatoâ€ nella memoria di Java. Per evitare
questo problema si puoÌ€ usare un metodo del pacchetto java.util:
22

System.out.println(Arrays.toString(args));

Per tradurre un intero in una stringa:
23

int n = Integer.parseInt(args[0]);

8

4

Lezione 4 - Astrazione procedurale

Lâ€™astrazione permette di astrarre dagli aspetti irrilevanti e di dimenticare dei dettagli, concentrandosi solamente su quelli rilevanti â†’ si introducono delle procedure.

4.1

UtilitaÌ€

Lâ€™astrazione procedurale permette di dividere il codice in procedure (cioeÌ€ porzioni di codice) per mettere in
evidenza lâ€™astrazione in due punti di vista:
â€¢ Astrazione per parametrizzazione: astrazione rispetto ai dati, vengono introdotti dei parametri formali
in modo che il programma funzioni indipendentemente dai valori che vengono inseriti â†’ Viene eliminato
il riferimento rispetto ai dati concreti
â€¢ Astrazione per specificazione: astrazione rispetto alla computazione, descrivendo cosa restituisce la
funzione se vengono forniti certi input. Non mi importa come faccio una certa cosa, ma che cosa
faccio. Lâ€™astrazione per specificazione viene utilizzata ogni qualvolta venga associato un commento
abbastanza esplicativo che permetta ad un utente di capire che cosa fa la procedura senza guardare il
codice
La modularizzazione funzionale rende piuÌ€ facile la:
1. ModificabilitaÌ€, cioeÌ€ la manutenzione, lâ€™estensione/ottimizzazione e il testing dato che si hanno piuÌ€ parti
di codice replicate nel programma. EÌ€ possibile modificare unâ€™astrazione senza modificare tutte le altre
astrazioni che la utilizzano (e il loro codice)
2. Comprensione (o localitaÌ€): avere moduli separati permette di comprendere il funzionamento di un
modulo indipendentemente dagli altri, riducendo il numero di effetti collaterali percheÌ eÌ€ possibile
sapere nel dettaglio che cosa fa ogni modulo, rendendo piuÌ€ facile la previsione di tutti i comportamenti
possibili (compresi quelli indesiderati). Grazie alla localitaÌ€ un programma puoÌ€ essere anche realizzato
da persone che lavorano su moduli indipendenti â†’ un utente puoÌ€ implementare unâ€™astrazione che
utilizza unâ€™astrazione di un altro utente

4.2

Comâ€™eÌ€ fatta la specificazione?

La specificazione viene fatta prima della scrittura del codice, viene prima descritto che cosa faraÌ€ la funzione
e quale dovraÌ€ essere lâ€™input. La specificazione viene fatta dal punto di vista:
1. Sintattico â†’ astrazione rispetto ai dati: nello header (o intestazione) viene indicato il tipo restituito e
i parametri formali nome(0 P0 ,1 P1 , )
2. Semantico â†’ che cosa fa la funzione?: per spiegarlo viene utilizzato un linguaggio informale ma preciso,
infatti con un linguaggio formale si rischierebbe di descrivere il come, che eÌ€ proprio cioÌ€ che lâ€™astrazione
per specificazione vuole evitare. Verranno quindi utilizzati degli accorgimenti linguistici â†’ 3 clausole
della Liskov (o JavaDoc)

9

Figure 1: Lâ€™input e lâ€™ambiente sono dati in pasto al programma che generano lâ€™output

Figure 2: Le clausole della Liskov
4.2.1

Clausola Requires (o precondizione)

Indica che cosa si aspetta la funzione dallâ€™input e dallâ€™ambiente , andando ad escludere alcuni valori dal
dominio. Se le precondizioni sono soddisfatte allora il funzionamento della funzione eÌ€ corretto. Se questa
clausola non eÌ€ presente nelle specifiche si parla di funzione totale quando il comportamento eÌ€ specificato
per tutti gli input ammissibili. Le funzioni totali vengono utilizzate in qualcosa di pubblico quando non si eÌ€
in grado di prevedere che cosa faraÌ€ lâ€™utilizzatore, in modo da assicurare che non avvengano effetti collaterali.
Le procedure parziali sono tutte le procedure che non sono totali. In esse viene posto un controllo sullâ€™input
e sono piuÌ€ efficienti/semplici percheÌ€ non eÌ€ necessario tenere in considerazioni valori particolari.
Javadoc: @param
4.2.2

Clausola Effects (o postcondizione)

Indica cosa la funzione restituisce in output e eventuali modifiche allâ€™ambiente, quale eÌ€ lâ€™effetto che si
ottiene. Javadoc: @return.
4.2.3

Clausola Modifies (o effetti collaterali)

Come la clausola Requires lâ€™ambiente e lâ€™input , ma indica anche le possibili modifiche dopo che la funzione eÌ€
stata eseguita, ad esempio se un oggetto viene passato per riferimento eÌ€ necessario indicare che cosa fa. Negli
effetti collaterali indico le modifiche di una struttura anche se eÌ€ lâ€™â€obbiettivoâ€ scritto nella postcondizioni.
Javadoc: inclusa nel testo.

4.3

Implementazione

Se certe procedure sono standalone (funzionano da sole) viene utilizzato il modificatore static. Se una
classe viene dichiarata come public significa che puoÌ€ essere da tutte le altre classi, anche al di fuori della
libreria in cui eÌ€ stata definita. I metodi private possono essere invocati solamente nella classe in cui
sono definiti, permettendo cosÄ±Ì€ allo sviluppatore un grado di libertaÌ€ maggiore, dato che non possono essere
invocati allâ€™esterno e che vengono invocati su un numero di variabili minore.
Nellâ€™implementazione eÌ€ necessario garantire che, se le precondizioni sono rispettate, la funzione abbia lâ€™effetto
dichiarato nelle postcondizioni. Se le precondizione non sono rispettate il comportamento corretto non eÌ€
garantito.

4.4

Come si progetta e valuta una buona astrazione procedurale

I criteri da rispettare sono due:
1. MinimalitaÌ€ dei vincoli che si stanno specificando: in questo modo si daÌ€ piuÌ€ libertaÌ€ allo sviluppatore,
vincolando meno lâ€™implementazione ed aumentando lâ€™efficienza. Lo svantaggio eÌ€ che si potrebbe non
specificare qualcosa e avere dei dettagli mancanti â†’ sottospecificazione (ad esempio indicando che
la radice eÌ€ una funzione che approssima).
2. La procedura deve implementare qualcosa di deterministico: sottospecificando potrebbe capitare che
la funzione restituisca output differenti eseguendola sugli stessi input. Una funzione deterministica,
su invocazioni successive con il medesimo input producano il medesimo output.

10

Ricorda
Non deterministico 6= nondeterministico. Quello che interessa a noi eÌ€ il primo, il secondo
viene utilizzato nellâ€™informatica teorica.
3. GeneralitaÌ€: le funzioni devono essere utili in un ampio insieme di contesti
4. SemplicitaÌ€: il comportamento di una funzione deve essere ben preciso e ben specificato

11

5

Eccezioni

Errori 6= Eccezioni. Lâ€™eccezione indica un comportamento particolare del codice di cui lâ€™utente deve essere
informato e non sempre coincide con un errore. Se voglio fare la ricerca in un array e passo un elemento che
non eÌ€ presente eÌ€ piuÌ€ comodo fare unâ€™eccezione che indicare un errore e fermare lâ€™esecuzione del programma.
Nellâ€™intestazione di una funzione il dominio eÌ€ specificato con i parametri formali e non eÌ€ possibile indicare
un sottoinsieme proprio dei possibili valori sui quali la funzione eÌ€ definita. Potrei indicarlo nelle precondizioni,
ma con valori al di fuori di quel dominio la funzione potrebbe fare di tutto, anche compromettere altre
porzioni della memoria â†’ funzioni parziali = la funzione viene eseguita correttamente solo su determinati
valori, per gli altri valori il comportamento non eÌ€ determinato. In questo caso la funzione non eÌ€ robusta (un
programma robusto continua a comportarsi in modo adeguato anche se vengono rilevati degli errori) e per
avere del codice che rispetti la grateful degradation (cioeÌ€ che venga indicato che ci sono stati degli errori
senza peroÌ€ danneggiare i dati. Se lâ€™input non eÌ€ valido allora la procedura non deve finire a quel punto o
continuare il lavoro distruggendo tutto, ma finire senza modificare o non distruggere nulla) si puoÌ€ agire in
due modi, indicando che câ€™eÌ€ stato un problema:
1. Vengono scelti alcuni valori per indicare che eÌ€ avvenuto un errore, restituendo NULL oppure -1. Non eÌ€
possibile fare sempre questa cosa se ho giaÌ€ utilizzato tutto il dominio Î˜, ad esempio la somma puoÌ€ essere
qualsiasi valore, quindi eÌ€ impossibile trovare un valore che indichi un problema. Un altro problema si
verifica quando utilizzo la funzione in una somma. In questo caso potrei non accorgermi se câ€™eÌ€ stato
un errore: y=3+sqrt(x) restituisce un numero, come faccio a sapere se allâ€™interno la somma eÌ€ stata
fatta con il valore dellâ€™errore?
Soluzione estendere il codominio: Î˜âˆª{âŠ¥}, come viene fatto da GO, che introduce v, err=f(...).
2. Eccezioni: meccanismo dellâ€™astrazione funzionale che indica che la funzione non eÌ€ potuta proseguire ed
il flusso di esecuzione si eÌ€ dovuto interrompere prematuramente sollevo unâ€™eccezione

5.1

Tipologie di eccezioni

Figure 3: Gerarchie delle eccezioni
Le eccezioni sono oggetti che appartengono ad una gerarchia di classi. Il tipo Exception eÌ€ un sottotipo
sia di Exception e di RunTime Exception, entrambi sottotipo di Throwable. Le eccezioni unchecked
sono sottotipi di RunTime Exception e di Error, mentre le checked sono sottotipi di Exception:
â€¢ checked (checked a compile time): sono gestite esplicitamente e devono seguire il catch or specify ossia
avere nellâ€™intestazione il throw-catch oppure il throws, altrimenti il compilatore restituisce un errore.
Si usano le eccezioni checked quando i metodi sono public e se il check eÌ€ oneroso.
â€¢ unchecked: non vengono esplicitamente gestite, non sono neÌ€ nellâ€™intestazione neÌ nel corpo del codice.
Di questa categoria fanno parte gli errori e le eccezioni a runtime. Possono essere utilizzate nei metodi
private dove si eÌ€ sicuri che nessuno altro utente oltre lo sviluppatore possa chiamare la funzione con
valori problematici. Vengono inoltre utilizzate quando eÌ€ facile fare un check.
12

Gestione
Dichiarazione
Quando eÌ€ meglio
utilizzarla?

Pro (se ben utilizzate)

Contro (se si abusa)

5.2

Checked
catch - specify
Specificazione + Throws
- Recoverable Conditions: quando ci
sono delle condizioni nelle quali il programma puoÌ€ non terminare in maniera
brutale
- Quando sono dovute da anomalie esterne al programma (e al programmatore) che non possono essere previste
con una assoluta certezza, come un errore di input da parte dellâ€™utilizzatore
- Separazione dal flusso di esecuzione
- Defensive Programming
- Maggiore robustezza del codice
- â€Reminderâ€ per il programmatore
- Maggiore leggibilitaÌ€
- Non devono essere utilizzate per modificare il flusso di esecuzione (come usare
le eccezioni per uscire da dei loop)
- Non rendere difficile lâ€™utilizzo del
codice quando lo stiamo condividendo
con altri programmatori

Unchecked
Specificarle solamente nella specificazione per non appesantire il codice
- Usualmente per la violazione delle precondizioni
- Anomalie interne al programma, come
errori di implementazione
- â€Programming Errorsâ€: anomalie che
possono essere risolte se il programmatore prestasse piuÌ€ attenzione

- Separazione dal flusso di esecuzione
- Defensive Programming
- Maggiore robustezza del codice

Non devono essere utilizzate per modificare il flusso di esecuzione (come usare
le eccezioni per uscire da dei loop)

Definire eccezioni

Una procedura che puoÌ€ lanciare unâ€™eccezione ha un header di questo tipo:
public static int fact (int n)
throw new NullPointerException, NotFoundException;
//posso anche creare delle nuove eccezioni
public static int fact (int n)
throw new NuovaEccezione; //NuovaEccezione.java devo definirla io

24
25
26
27
28

Il tipo eccezione ha due costruttori (overload), uno eÌ€ vuoto e il secondo inizializza lâ€™oggetto eccezione in
modo da contenere una stringa.
Exception NuovaEcc1 = new NewKindOfExc(); //costruttore vuoto
Exception NuovaEcc2 = new NewKindOfExc("Eccezione");

29
30

5.3

Gestire eccezioni

La Liskov dice che tutte le eccezioni che potrebbero essere lanciate vanno specificate nellâ€™intestazione di ogni
funzione, tuttavia eÌ€ unâ€™operazione molto difficile da fare e nemmeno le api sono realizzate in questo modo.
Per gestire unâ€™eccezione eÌ€ necessario racchiudere tra try una porzione di codice che sospettiamo che sollevi
unâ€™eccezione e, se nella porzione di codice si verifica lâ€™eccezione, lâ€™esecuzione del blocco cessa istantaneamente
e viene trasferita a dei blocchi catch che sono definiti per lâ€™eccezione che eÌ€ occorsa oppure per un supertipo
dellâ€™eccezione che eÌ€ occorsa. Dopo i blocchi catch eÌ€ anche possibile definire dei blocchi finally che
vengono sempre eseguiti, sia che lâ€™eccezione avvenga che no. Solitamente in questi blocchi si chiudono le
risorse allocate facendo delle azioni di cleanup.
Per fare in modo che una procedura lanci unâ€™eccezione:
31

if (n<0) throw new NonPositiveException("Num.fact");

13

Questa porzione di codice lanceraÌ€ un oggetto del tipo NonPositiveException

5.4

Programmare con le eccezioni

Le eccezioni possono essere gestite specificamente, in cui il catch risponde alla situazione specifica, oppure
generalmente, dove il catch fa unâ€™azione generica, come ad esempio riavviare il programma o ripristinare
una versione precedente senza risolvere nello specifico il problema che ha lanciato lâ€™eccezione. Per gestire
unâ€™eccezione ci sono due modi:
1. Reflecting, le eccezioni vengono riportate al giusto livello di astrazione, quindi viene propagata, ovvero
quando una certa procedura P solleva unâ€™eccezione senza avere un blocco try in P. In questo caso
Java propaga lâ€™ecezione al chiamante di P.
2. Masking, eÌ€ presente il blocco catch ma in qualche modo lâ€™errore viene annullato, riprendendo il
normale flusso di esecuzione â†’ puoÌ€ essere molto pericoloso
Quando si usano le eccezioni?
Per rendere le funzioni parziali delle funzioni totali, in modo da eliminare i requires indicando negli
effects quali sono e come si comportano le eccezioni. EÌ€ importante descrivere anche come esse vadano a
modificare lâ€™ambiente, quando ad esempio viene eseguita una porzione di codice, lâ€™ambiente viene modificato
e viene lanciata lâ€™eccezione.
Ecco alcune eccezioni utilizzate in laboratorio:
â€¢ IllegalArgumentException, quando ad esempio viene inserito come argomento un numero non
valido
â€¢ NullPointerExceprtion, quando come argomento viene passato un NULL

14

6

Lezione 6 - Astrazione sui dati

Se si vogliono rappresentare delle informazioni che non possono essere rappresentati in modo fedele dai
tipi provvisti dal linguaggio eÌ€ necessario astrarre e costruire una rappresentazione semplificata â†’ si vuole
â€estendereâ€ i tipi elementari del linguaggio.
Si riflette sul comportamento e il sul significato delle entitaÌ€, ovvero il cosa senza preoccuparsi del come.
I nuovi tipi creati dovranno incorporare lâ€™astrazione:
â€¢ per parametrizzazione, nelle procedure si ottiene utilizzando i parametri. Il dato viene trasformato in
un parametro che svolge il ruolo di dato nella computazione.
â€¢ per specificazione, che si ottiene facendo diventare le operazioni parte del tipo stesso. Allontana dal
dettaglio implementativo, vengono descritti i comportamenti ma non la tecnicalitaÌ€ su di essi.

Ricorda
Astrazione dei dati = Oggetti + Operazioni. Grazie allâ€™astrazione sui dati eÌ€ possibile preoccuparsi
successivamente di come implementare le strutture dati. Prima si ragiona suii tipi astratti e sulle
operazioni che eÌ€ possibile fare con, poi si implementa il tutto.

6.1

Specificazione per i tipi di dati

Lâ€™astrazione per specificazione permette di descrivere il comportamento dei tipi ed eÌ€ definita dalla sintattica
e dal â€testoâ€, cioeÌ€ dei commenti appropriati che descrivono che cosa fa la classe. Classe: descrizione di come
sono costruiti gli oggetti, contengono la specificazione e lâ€™implementazione. Ad esempio la classe persona
definisce come eÌ€ fatta la persona e che cosa puoÌ€ fare. Ogni classe ha dei costruttori che sono utilizzati per
inizializzare nuovi oggetti di un tipo e dei metodi di istanza che permettono di accedere e modificare gli
oggetti. Nella classe viene utilizzato .this che viene utilizzata per parlare dellâ€™oggetto corrente.
I costruttori devono avere lo stesso nome della classe e vengono invocati. Gli attributi sono un elenco
di variabili dichiarate con il loro tipo, cosÄ±Ì€ indicati T nome che formano la rappresentazione. Queste
variabili sono valorizzate quando viene costruita unâ€™istanza della classe. Ogni oggetto fa riferimento ad
uno spazio nello heap.
32
33

visibility class dname{
//OVERVIEW: descrizione dellâ€™astrazione sui dati

34

//attributi o campi (fields)
//costruttori
//metodi

35
36
37
38
39

}

6.2

Metodi

I metodi di istanza permettono di descrivere il comportamento dellâ€™oggetto e sono suddivisi in quattro
categorie (anche se sintatticamente non eÌ€ possibile farlo, posso farlo solamente lungo una descrizione testuale):
â€¢ Metodi di creazione, che creano un oggetto o un tipo â€da zeroâ€. Quasi tutti i costruttori sono metodi
di creazione. (5.8.2 PDJ)
â€¢ Metodi di mutazione, alterano lâ€™entitaÌ€ sulla quale vengono invocati
â€¢ Metodi di osservazione, non alterano lo stato dellâ€™oggetto
â€¢ (Metodi di produzione/fabbricazione): producono altri oggetti dello stesso tipo, ad esempio quando
creo una nuova matrice copiandone unâ€™altra
I metodi e i costruttori hanno a che fare con gli oggetti, non con la classe, per questo non serve STATIC
15

6.3

IntSet

Insieme mutabile di Integer che puoÌ€ essere modificata e interrogata in vari modi. Il costruttore di IntSet
inizializza un nuovo Set vuoto su cui eÌ€ possibile utilizzare i metodi. Quando viene aggiungo un elemento al
Set che eÌ€ giaÌ€ presente oppure quando si cerca di rimuovere un elemento che non eÌ€ presente, i metodi non
restituiscono unâ€™eccezione. Ogni istanza di IntSet fa riferimento ad uno spazio nello heap.
class IntSet

6.4

Poly

Insieme immutabile per polinomi con coefficienti interi che una volta creati non possono essere modificati
(non esistono metodi di mutazione), ma su cui possono essere addizionati, sottratti e moltiplicati. Possono
essere visti come degli array in cui lâ€™i-esimo elemento eÌ€ il coefficiente dellâ€™i-esimo esponente.
class Poly

16

7

Lezione 7 - Metodi aggiungitivi

Come giaÌ€ spiegato, alla radice della gerarchia câ€™eÌ€ Object e ogni oggetto della gerarchia deve essere in grado
di avere tutte le competenze dei genitori seguendo il Liskov Sustitution Principle A volte peroÌ€ il comportamento del genitore non eÌ€ abbastanza specifico per i sottotipi.
== viene utilizzato per confrontare i tipi primitivi, mentre il confronto tra tipi riferimento eÌ€ piuÌ€ complicato
dato che == indica se i due oggetti occupano lo stesso spazio di memoria â†’ viene introdotto il metodo
equals che permette di identificare due oggetti come â€ugualiâ€ quando il loro comprtamento eÌ€ uguale. EÌ€
peroÌ€ rischioso avere una nozione di uguaglianza che dipende dal tempo, quindi si agisce in modo differente
a seconda degli oggetti:
â€¢ Oggetti mutabili: Secondo Liskov tutti gli oggetti mutabili non possono essere indistinguibili percheÌ€
possono sempre mutare quindi la Liskov introduce il concetto di similaritaÌ€, che peroÌ€ non eÌ€ cosÄ±Ì€ diffuso
nel mondo reale. Per questo motivo utilizzeremo ancora equals considerandoli uguali fincheÌ€ non viene
invocato un metodo mutazionale.
â€¢ Oggetti immutabili: posso scrivere il metodo equals.

7.1
41

Distinzione di due oggetti con equals

boolean equals (Object o)

Come prima cosa eÌ€ necessario verificare che i due oggetti siano dello stesso tipo â†’ o.istanceOf T . Poi
si eseguono dei controlli sulle cose che sono ritenute uguali. Si esegue un casting T v = (T )o e si fanno i
controlli this.x
v.x.
Nella documentazione di Object eÌ€ specificato che equals deve soddisfare alcune proprietaÌ€:
â€¢ RiflettivitaÌ€
â€¢ Simmetria
â€¢ TransitivitaÌ€
â€¢ Consistenza: multiple invocazioni di equals devono sempre ritornare sempre o true o false almeno
che non vengano chiamati metodi mutazionali.

7.2

hashCode

Dentro Object câ€™eÌ€ un metodo simile ad equals chiamato hashCode (che quindi viene ereditato) che serve
a mappare gli oggetti sugli interi â†’ Problema della piccionaia, ci sono piuÌ€ oggetti che interi, quindi la
funzione h : O â†’ int non puoÌ€ essere iniettiva.
EÌ€ necessario implementare equals in modo che lâ€™uguaglianza di equals equivalga a quella di hashCode.
Non vale peroÌ€ il contrario: x.equals() == y.equals() â‡’ x.hashCode()==y.hashCode()
ma non vale x.hashCode()==y.hashCode()x.equals() == y.equals().
Implementazione di hashCode:
Creo una variabile result e per ogni campo sommo lâ€™hashCode:
42
43
44
45
46
47
48

49

@Override
public int hashCode(){
int result = Integer.hashCode(numerator);
//a result devo aggiungere tutti gli altri campi in questo modo:
result = 31 * result + Integer.hashCode(denominator);
return result;
// c i o
return 31 * Integer.hashCode(denominator) + Integer.hashCode(
numerator);
}

17

Ricorda
Le collezioni permettono di immagazzinare oggetti omogenei per tipo. Nelle collezioni hashCode e
equals devono essere implementate correttamente. Nelle collezioni eÌ€ necessario aggiornare result
ad ogni membro della collezione.

7.3

Rapporto tra rappresentazione ed astrazione

Ci sono delle situazioni in cui i rapporti tra rappresentazione (sintattica) e astrazione devono essere gestiti con
attenzione, in unâ€™istanza di IntSet il numero di elementi potrebbe non coincidere con il numero di elementi
di size, oppure negli elementi ci sono piuÌ€ valori ripetuti â†’ non tutti i possibili valori che vengono messi
in una rappresentazioni corrispondono ad unâ€™astrazione oppure diverse valorizzazioni nella rappresentazioni
coincidono con la stessa astrazione.
50
51
52
53

IntSet
int []elem; //{1, 3, 5, 3}
int size; //size=12
//astrazione e rappresentazione non coincidono

Dei â€pontiâ€ che permettono di passare dallâ€™implementazione verso lâ€™astrazione sono la funzione di astrazione (AF) e lâ€™invariante di rappresentazione (RI).
7.3.1

Funzione di astrazione (AF)

Se ho una serie di attributi a0 , a1 , ..., an potranno assumere un valore qualsiasi dei loro domini A0 , A1 , ..., An
e facendo il prodotto cartesiano dei domini si ottiene lo spazio di tutti i valori che puoÌ€ assumere lo stato
dellâ€™oggetto: A = A0 Ã— A1 Ã— ... Ã— An .
La funzione di astrazione permette di associare ad un certo possibile insieme di valori (dominio),
quindi un certo A, un oggetto nellâ€™astrazione (codominio): AF : A â†’ . AF eÌ€ una funzione non
iniettiva, dato che dimentica i dettagli, ad esempio mappando {5, 7, 3} e {5, 7, 3} nella stessa entitaÌ€ {3, 5, 7}.
Un esempio di AF eÌ€ il metodo toString.
7.3.2

Invariante di rappresentazione (RI)

Lâ€™invariante di rappresentazione indica, per un qualunque insieme di valori, quali corrispondono oppure no
ad unâ€™entitaÌ€ valida nellâ€™astrazione: RI : A â†’ {V, F }
Il metodo boolean repOk() (idea della Liskov, non eÌ€ nelle API ) eÌ€ un modo per implementare lâ€™RI che
esplora i valori negli attributi e restituisce TRUE se i valori vanno bene (ad esempio se non ci sono duplicati
quando rappresento un insieme). Non eÌ€ peroÌ€ attiva di default nella macchina virtuale ma bisogna esplicitarla
da terminale quando eseguo il programma java -ea test, dove -ea sta per Enable Assertions. Le
asserzioni sono un meccanismo linguistico grazie al quale si puoÌ€ decorare il codice in modo che durante
lâ€™esecuzione del codice vengano controllati alcuni predicati.
Le asserzioni sono una sorta di repOk piuÌ€ granulare, sono dei predicati che si annotano nel codice per i
quali la macchina virtuale che esegue i controlli di validitaÌ€.
assert e: se lâ€™espressione non eÌ€ vera la macchina virtuale solleva lâ€™eccezione AsserException.
54
55
56
57

public void hit() {
hits++;
assert repOk();
}

58
59
60
61
62

public void removeHit() {
if (hits > 0) hits--;
assert repOk();
}

63

18

64
65
66
67
68
69
70

public int hits() {
return hits;
}
//se repOk restituisce false il compilatore d
boolean repOk() {
return hits >= 0;
}

7.4

errore

MutabilitaÌ€ ed effetti collaterali

Lâ€™implementazione puoÌ€ essere resa immutabile con il modificatore final.
Unâ€™entitaÌ€ mutabile ha unâ€™implementazione mutabile ma unâ€™entitaÌ€ immutabile potrebbe avere unâ€™implementazione
mutabile. Una rappresentazione mutabile non eÌ€ un problema fincheÌ€ non viene esposta la rappresentazione.
Immaginiamo di avere un polinomio ed una funzione che restituisca il suo grado: quando non eÌ€ ancora stata
chiamata il valore del grado eÌ€ -1, quando viene chiamata per la prima volta il grado viene modificato e
memorizzato in modo tale che possa essere restituito allâ€™utente senza scorrere nuovamente tutta la lista. Il
polinomio eÌ€ immutabile ma la sua implementazione eÌ€ mutabile â†’ effetto collaterale benevolo (B. Side
Effect): le modifiche non sono visibili al di fuori dellâ€™implementazione.
Ad esempio, nei numeri razionali, il metodo equals dovrebbe implementare reduce, che riduce ai minimi
termini. Questo eÌ€ un esempio di BSE. Sempre in questo esempio (numeri razionali) RI eÌ€ cosÄ±Ì€ costituito:
â€¢ La lista dei coefficienti deve essere un riferimento non nullo
â€¢ Le coppie (coefficiente, grado) devono essere non nulle
â€¢ Le coppie (coefficiente, grado) non devo essere duplicate
â€¢ Il valore dentro il grado eÌ€ -1 oppure coincide con lâ€™esponente piuÌ€ grande di quelli presenti nella lista.

Ricorda
Per implementare la data abstraction eÌ€ necessario ottenere il local reasoning, ovvero essere in grado
di garantire che una classe eÌ€ corretta solamente esaminando il suo codice. Il local reasoning eÌ€ valido
solamente se la rappresentazione degli oggetti astratti non puoÌ€ essere modificata al di fuori della
loro implementazione. Se non câ€™eÌ€ la il local reasoning la rappresentazione si dice esposta, quindi i
componenti della rappresentazione sono accessibili dallâ€™esterno della classe.
Lâ€™esposizione si verifica quando vengono dichiarate delle variabili non private. Lâ€™esposizione della rappresentazione eÌ€ errata per:
1. Se la rappresentazione eÌ€ mutabile eÌ€ possibile alterarla
2. Espongo un dettaglio implementativo, quindi sono legato per sempre a mantenere quella rappresentazione, ad esempio se ho un vettore non potroÌ€ mai usare una base di dati
71
72
73
74
75
76

/**
* {@code IntSet}s are mutable, unbounded sets of integers.
* <p>A typical IntSet is \( S = \{x_1, \ldots, x_n \} \).
*/
public class IntSet {

77
78
79
80
81

// Fields
//INVARIANTE DI RAPPRESENTAZIONE (scritta esplicitamente)
//els non
null
//els non contiene elementi nulli

19

//els non

82

deve contenere due interi uguali ( p e r c h

un insieme)

83
84
85

/** The {@link List} containing this set elements. */
private final List<Integer> els;

86
87

// Constructors

88
89
90
91
92
93

/**
* Initializes this set to be empty.
*
* <p>Builds the set \( S = \varnothing \).
*/

94
95

public IntSet() {

96

//Lâ€™INVARIANTE DI RAPPRESENTAZIONE
INVARIATO AL TERMINE DEI COSTRUTTORI?
//ArrayList quando viene creata
vuota, non
NULL dato che new non
restituisce null, non contiene elementi nulli e non contiene elementi
duplicati dato che
vuota
els = new ArrayList<>();

97
98

99
100

}

101
102
103
104
105
106
107

108
109
110

/**
* A *copy constructor*, provided to implement {@link #clone()}.
*
* @param other the {@code IntSet} to copy from.
*/
// COSTRUISCE UN INSIEME DI INTERI A PARTIRE DA UN ALTRO INSIEME DI INTERI COPIANDO
IL COSTRUTTORE COPIA DI ARRAYLIST
//PER DIMOSTRARE IL PRESERVAMENTO DI RI DEVO FARE DUE IPOTESI INDUTTIVE
//1. ARRAY LIST SI COMPORTA IN MODO CORRETTO
//2. OTHER SIA STATO COSTRUITO IN MODO CORRETTO ( c i o non
null, non contiene
elementi nulli o elementi duplicati).

111
112
113
114

private IntSet(IntSet other) {
els = new ArrayList<Integer>(other.els);
}

115
116
117
118
119
120
121
122

123
124
125
126
127
128

// Methods
// GUARDO TUTTI I METODI CHE HANNO A CHE FARE CON Lâ€™INVARIANTE
/**
* Looks for a given element in this set.
*
* @param x the element to look for.
* @return the index where {@code x} appears in {@code els} if the element belongs
to this set, or
-1
*
*/
//NON MODIFICA ELSE
private int getIndex(int x) {
return els.indexOf(x);
}

129
130
131
132
133
134
135

/**
* Adds the given element to this set.
*
* <p>This method modifies the object, that is: \( Sâ€™ = S \cup \{ x \} \).
*
* @param x the element to be added.

20

136
137

138
139
140

141
142

*/
// MODIFICA ELSE. DEVO CONTROLLARE Lâ€™RI. IL BOXIN NON P U PRODURRE UN NULL, QUINDI
ELS NON
NULL, NON CI SONO DUPLICATI E ELS NON CONTIENE NULL, DATO CHE GLI
AGGIUNGO UN ELEMENTO NON NULL
public void insert(int x) {
if (getIndex(x) < 0) els.add(x);
//se aggiungo un elemento che era g i presente nella lista allora non lo
aggiungo,
// c o s viene rispettato lâ€™invariante di rappresetazione
}

143
144
145
146
147
148
149
150
151
152
153
154
155
156
157

/**
* Removes the given element from this set.
*
* <p>This method modifies the object, that is: \( Sâ€™ = S \setminus \{ x \} \).
*
* @param x the element to be removed.
*/
public void remove(int x) {
int i = getIndex(x);
if (i < 0) return;
int last = els.size() - 1;
els.set(i, els.get(last));
els.remove(last);
}

158
159
160
161
162
163
164
165
166
167
168
169

/**
* Tells if the given element is in this set.
*
* <p>Answers the question \( x\in S \).
*
* @param x the element to look for.
* @return whether the given element belongs to this set, or not.
*/
public boolean isIn(int x) {
return getIndex(x) != -1;
}

170
171
172
173
174
175
176
177

/**
* Returns the cardinality of this set.
*
* <p>Responds with \( |S| \).
*
* @return the size of this set.
*/

178
179

180
181
182
183

//COME VERIFICO LA CORRETTEZZA DI QUESTO METODO? Controllo operazioni AF. Se assumo
per induzione che RI sia valido quando inizia il metodo e i parametri siano
corretti (qui non ci sono), allora il valore restituito dal metodo ( c i o lâ€™
implementazione) corrisponde ad una certa propriet dellâ€™ e n t i t che sto
studiando (in questo caso la cardinalit )
AF cosa fa? els -> {els[0], els[1],...,els.get(els.size()-1)}
public int size() {
return els.size();
}

184
185
186
187

/**
* Returns an element chosen at random from this set.
*

21

* @return an arbitrary element from this set.
* @throws EmptyException if this set is empty.
*/
public int choose() throws EmptyException {
if (els.size() == 0) throw new EmptyException("Canâ€™t choose from an empty set");
return els.get(els.size() - 1);
}

188
189
190
191
192
193
194
195

@Override
public String toString() {
if (els.size() == 0) return "IntSet: {}";
String s = "IntSet: {" + els.get(0);
for (int i = 1; i < els.size(); i++) s = s + ", " + els.get(i);
return s + "}";
}

196
197
198
199
200
201
202
203

@Override
public IntSet clone() {
return new IntSet(this);
}

204
205
206
207
208

}

22

8

Lezione 8 - Verifica mantenimento astrazione

Una descrizione formale eÌ€ una descrizione precisa di una certa realtaÌ€, caratterizzata da:
â€¢ Linguaggio (+grammatica)
â€¢ Semantica (ovvero i simboli significano qualcosa)
â€¢ â€Calcoloâ€: assiomi e teoremi
In Java lâ€™implementazione eÌ€ formale e il linguaggio di programmazione eÌ€ uno, mentre lâ€™astrazione non lo
eÌ€, non esiste un unico â€quadro di riferimentoâ€ â†’ nellâ€™astrazione si ragiona in modo informale.
Voglio prendere AF e RI per verificare la correttezza. Lâ€™implementazione eÌ€ costruita in maniera plausibile?
1. Preservamento delle invarianti di rappresentazione, cioeÌ€ che RI sia valido per qualunque oggetto della
classe ed in qualunque momento. EÌ€ importante percheÌ tramite RI si sono costruiti i fondamenti
2. Correttezza delle operazioni: si utilizza la funzione di astrazione, che permette da passare dallâ€™implementazione
al mondo dellâ€™astrazione
3. Invariante di astrazione (Abstraction Invariant), cioeÌ€ delle proprietaÌ€ che valgono solo nel mondo
dellâ€™astrazione, ad esempio un elemento di un insieme non puoÌ€ essere negativo. La parte di verifica
dellâ€™invariante di astrazione riguarda solamente il sottoinsieme del codice che muta lo stato dellâ€™oggetto.
EÌ€ come se fosse lâ€™analogo dellâ€™invariante di rappresentazione per lâ€™oggetto astratto
Nellâ€™implementare il codice si sceglie una rappresentazione riflettendo su AF e RI.
La tecnica dimostrativa eÌ€ una tecnica induttiva: se Ï€(e) vale, dimostro che vale anche Ï€(e + 1). Ad
esempio se Ï€(e) vale e e < f â‡’ Ï€(f ), dove Ï€ eÌ€ la dimostrazione di correttezza ed e e f sono gli oggetti.

8.1

Preservamento RI

Lâ€™invariante di rappresentazione deve essere vera ogni volta che lâ€™oggetto viene utilizzato al di fuori della sua
classe. Per verificare che lâ€™invariante di rappresentazione sia invariato:
â€¢ EÌ€ necessario che RI sia vero al termine dei costruttori
â€¢ Analizzare i metodi che alterano la rappresentazione (metodi di Mutazione + BSE + Produttori). Non
bisogna controllare solo i metodi mutazionali, dato che ci potrebbero essere dei metodi con degli effetti
collaterali benevoli.

8.2

Correttezza delle operazioni

Controllo molto piuÌ€ delicato percheÌ le operazioni accedono anche alle informazioni dellâ€™oggetto. Non controllo
solo i metodi di mutazione ma tutti, anche quelli di osservazione.

Ricorda
Il salto tra implementazione ed astrazione eÌ€ realizzato grazie a RI e AF
Le specificazioni sono scritte in termini di oggetti astratti mentre lâ€™implementazione manipola una rappresentazione concreta. EÌ€ quindi necessario guardare lâ€™implementazione e lâ€™entitaÌ€, il salto tra uno e lâ€™altro,eÌ€
AF
fatto da AF: Implementazione âˆ’âˆ’â†’ EntitaÌ€
//COME VERIFICO LA CORRETTEZZA DI QUESTO METODO? Controllo operazioni AF. Se assumo
per induzione che RI sia valido quando inizia il metodo e i parametri siano corretti (qui non ci sono), allora
il valore restituito dal metodo (cioeÌ€ lâ€™implementazione) corrisponde ad una certa proprietaÌ€ dellâ€™entitaÌ€ che sto
studiando (in questo caso la cardinalitaÌ€).
â€¢ Nei metodi di osservazione si fa unâ€™ipotesi induttiva sul fatto che this sia corretto
23

â€¢ Nei metodi di mutazione si fa unâ€™ipotesi induttiva sul fatto che siano scorretti this e i parametri
â€¢ Nei metodi di produzione si fa unâ€™ipotesi induttiva sul fatto che siano scorretti this, i parametri e su
parametri other, ossia altri oggetti dello stesso tipo

8.3

Preservazione degli AI

Vengono controllati solo i metodi che alterano la rappresentazione.
Un invariante di rappresentazione potrebbe essere la cardinalitaÌ€ di un insieme, che eÌ€ sempre maggiore di
zero: |S| â‰¥ âˆ…. Per dimostrarlo devo farlo per induzione, verificare che valga in costruzione e nei metodi che
lo alterano, come il metodo che lo altera.
Quando commento

8.4

MutabilitaÌ€

La mutabilitaÌ€ eÌ€ una proprietaÌ€ dellâ€™implementazione ma non dellâ€™astrazione. Possono esserci entitaÌ€ mutabili
per loro natura ma per le quali puoÌ€ convenire utilizzare unâ€™astrazione immutabile. I contenitori sono mutabili
(SET, LIST,...) ma non sempre le loro implementazioni devono essere mutabili, ad esempio unendo due
insiemi posso creare un nuovo insieme formato dallâ€™unione dei due. Bisogna tenere in considerazione un
giusto tradeoff tra sicurezza ed efficienza:
1. Sicurezza: con entitaÌ€ immutabili eÌ€ piuÌ€ semplice ragionare sul codice, non puoÌ€ accadere che un metodo
mutazionale comprometta lâ€™invariante di rappresentazione. Vengono semplificate le dimostrazioni ma
ci potrebbero essere molte allocazioni di memoria, come quando scrivo s+="..."
2. Efficienza: con entitaÌ€ mutabili lâ€™efficienza eÌ€ maggiore
Il punto di riferimento eÌ€ lâ€™entitaÌ€ che voglio modellare â†’ si cerca di costruire lâ€™astrazione tenendo conto che
la sicurezza eÌ€ piuÌ€ importante dellâ€™efficienza, per questo si tende a preferire implementazioni immutabili.

8.5

Adeguatezza

Quando progettiamo unâ€™astrazione eÌ€ necessario fornire allâ€™entitaÌ€ tutti i metodi per poter operare su di essa
nei modi intesi. Una definizione rudimentale di adeguatezza puoÌ€ essere raggiunta fornendo allâ€™astrazione:
â€¢ Costruttore
â€¢ Metodi di osservazione
â€¢ Metodi di mutazione, se lâ€™oggetto eÌ€ mutabile
â€¢ Metodi di produzione, necessari se lâ€™oggetto eÌ€ immutabile, infatti il costruttore potrebbe generare
insiemi vuoti
â€¢ Il â€tipoâ€ deve essere completamente popolato, il che significa che eÌ€ possibile ottenere/costruire ogni
stato nellâ€™astrazione tramite i metodi sopracitati.

8.6

LocalitaÌ€ e modificabilitaÌ€ nellâ€™astrazione dei dati

La localitaÌ€ richiede che la rappresentazione sia modificabile solamente attraverso lâ€™implementazione. La modificabilitaÌ€ richiede che lâ€™accesso alla rappresentazione, anche ai componenti immutabili, avvenga allâ€™interno
dellâ€™implementazione del tipo, infatti se lâ€™accesso avvenisse in un altro modulo non si potrebbe modificare
lâ€™implementazione senza avere ripercussioni sullâ€™altro modulo.

24

9

Astrazione iterazione

Alcune classi che abbiamo costruito ci permettono di conservare entitaÌ€ omogenee, come IntSet, Poly,
Queue...
Questi contenitori vengono sviluppati insieme ad una serie di comportamenti adeguati, ma ci potrebbero
essere delle operazioni aggiuntive che sono plausibili eseguire sul contenitore che peroÌ€ non ricadono nelle loro
competenze naturali. Ad esempio,in un insieme, potrei voler calcolare la somma dei suoi elementi oppure il
valore massimo anche se non sono competenze naturale degli insiemi. Queste funzioni aggiuntive possono
essere implementate:
â€¢ Internamente: viene creato un nuovo IntSet in cui vengono implementate le funzioni aggiuntive
â€¢ Esternamente: si crea una funzione che restituisce il vettore di IntSet ma eÌ€ una soluzione critica
percheÌ€ si espone la rappresentazione. Un altro modo eÌ€ quello di restituire una copia del contenuto,
nel caso di IntSet si potrebbe creare una copia del vettore e lavorare su di esso. In questo caso il
problema eÌ€ che lâ€™operazione di copia eÌ€ onerosa dal punto di vista temporale e computazionale.
Il metodo migliore per aggiungere queste funzioni eÌ€ quello di utilizzare unâ€™astrazione iterazione esterna. Il contenitore viene dotato di un generatore che produce gli elementi prelevandoli uno alla volta da
IntSet.

9.1

Come viene specificata lâ€™iterazione?

Per utilizzare lâ€™astrazione iterazione si utilizza lâ€™iteratore, una procedura speciale che restituisce un oggetto
generatore, che tiene traccia dello stato dellâ€™iterazione nella rappresentazione. Per implementare un iteratore eÌ€ necessario scrivere il codice e implementare una classe per il suo generatore. Per ogni iteratore eÌ€
necessaria un generatore (classe).
â€¢ Un iteratore eÌ€ un metodo che restituisce un generatore. Unâ€™astrazione puoÌ€ avere piuÌ€ iteratori. Le
specifiche dellâ€™iteratore definiscono il comportamento del generatore
â€¢ La classe che implementa lâ€™iteratore (implements iterator) eÌ€ chiamata generatore. Un generatore eÌ€ un oggetto che produce gli elementi utilizzati nellâ€™iterazione e ha i metodi hasNext e next.
Questi due metodi devono essere sempre implementati dato che lâ€™iteratore deve soddisfare il contratto
dellâ€™interfaccia
Tutti i generatori sono sottotipi dellâ€™interfaccia Iterator. Per costruire un iteratore eÌ€ necessario creare
una nuova classe:
//generatore
public interface Iterator{
public boolean hasNext();
public Object next();
}

210
211
212
213
214
215
216

class SetElements implements iterator<Integer>??

217

public class IntAdder{
public static void main (String[] args){
List<Integer> lst = List.of(1,2,3,4);

218
219
220

int sum=0;
Iterator<Integer> it= lst.iterator(); //questo metodo restituisce un iteratore
while (it.hasNext()){
int x=it.next();
sum+=x;
}

221
222
223
224
225
226

}

227
228

}

25

Questa scrittura, troppo lunga, eÌ€ stata sostituita con una versione piuÌ€ compatta e veloce, il for each.
Per utilizzarlo eÌ€ necessario indicare nella classe implements Iterator<Integer>.
233

iterator it = o.
iterator();
while (it.hasNNext()){
E x=it.next();

229

230
231
232

}

234
235
236
237
238

for (E x : o) //viene estratto automaticamente l
â€™iteratore da o
//con i due punti viene ciclato
List <Integer> lst = List.of(1, 2, 3, 4);
for (Integer x : lst){
sum+=x;
}

Per esseri sicuri che si sia il metodo iterator (nellâ€™esempio sopra o.iterator) eÌ€ necessario implementare
lâ€™iteratore con unâ€™interfaccia, come ad esempio nellâ€™IntSet. Lâ€™interfaccia permette di fornire ulteriori competenze ad un oggetto ed in questo caso deve avere un metodo che restituisce un iteratore che si chiami
â€iteratorâ€.
interface Iterable <E>{
iterator<E> iterator();
//il for-each funziona su tutti gli oggetti iterabili, questo permette che
funzioni
}

239
240
241

242

Ricorda
Se gli oggetti di tipo T hanno almeno un iteratore di nome iterator, allora la classe T eÌ€ una classe
iterabile (T implements iterable). Iterabile = câ€™eÌ€ esattamente un metodo di nome iterator
che restituisce un Iterator (cioeÌ€ un generatore per Liskov) â†’ in questo caso T implements iterabile)
â†’ https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html

9.2

Nested class

In un generatore eÌ€ necessario rappresentare:
â€¢ Lo stato del contenitore, che deve essere privato
â€¢ Lo stato del generatore deve comunicare con lo stato del contenitore, che eÌ€ peroÌ€ private e non
potrebbe essere acceduto. Per risolvere il problema si utilizzano le Nested Class.
Le classi interne vengono utilizzate per non esporre la rappresentazione, in modo che sia possibile accedere
anche alle istanze private della classe â€superioreâ€. A queste istanze private non eÌ€ possibile accedere con
un pezzo di codice che eÌ€ fuori da quella classe, ma eÌ€ possibile accederci tramite le classi interne. I vantaggi
delle classi interne sono il naming e la visibilitaÌ€ (dentro essa câ€™eÌ€ una visibilitaÌ€ degli attributi privati della
classe esterna.
Le classi interne possono essere:
â€¢ Static nested classes: implementate per ragioni di naming. Non hanno nessuna relazione con gli oggetti
della classe â€superioreâ€ quindi non eÌ€ possibile riferirsi a this della superclasse. Il metodo statico eÌ€
globale per tutta la classe, non esiste nessuna istanza this, allo stesso modo la classe statica vale per
tutte le istanze quindi non eÌ€ possibile riferirsi ad una particolare istanza â†’ si utilizza this
â€¢ Inner classes (non static) â†’: possono essere locali oppure anonime. Noi implementeremo quelle anonime, ossia delle classi implementate dentro ad un metodo. Nelle Inner Classes per creare un oggetto
nella classe interna devo scrivere y=x.new Y(), in questo modo y viene costruito solo a partire da
una istanza di x:
243
244

Class X{
Class Y{

26

y=x.new Y();
}

245
246

}

247

9.3

Implementazione in IntSet
//il codice di elementGenerator, per il prinicipo di sostituziome, dovrebbe avere
i metodi dentro iterator
//ma iterator
unâ€™interfaccia, quindi ha solo le signature e non il codice.
Prima devo implementare il codice
//devo implementare hasNext e Next

248

249

250
251

//QUESTO
UN ITERATORE, ossia un metodo che restituisce un generatore
//EFFECTS: ritorna lâ€™iteratore
public Iterator<Integer> iterator(){
return new ElementsGenerator(this); //restituisco un iterator = restituisco lâ€™
istanza di una classe che implementa iterator
}

252
253
254
255

256
257
258
259
260

//

261
262
263
264
265
266
267

//QUESTO E UN GENERATORE (classe che implementa iterator)
static nested p e r c h c o s posso avvedere ai membri privati di els
static class ElementsGenerator implements Iterator<Integer>{
private IntSet set;
private int idx; //indice dellâ€™ultimo elemento che ha restituito
//costruttore
ElementsGenerator (IntSet set){
this.set=set;
}

268

@Override
public boolean hasNext(){
return idx<set.els.size();
}

269
270
271
272
273

@Override
public Integer next(){
if (!hasNext()) throw NoSuchElementException();
return set.els.get(idx++);
}

274
275
276
277
278

}

279

9.4

Classi anonime

Le classi anonime sono delle espressioni che corrispondono ad unâ€™istanza, eÌ€ possibile crearne solamente una.
Concettualmente sono identiche alle Inner Class ma sono piuÌ€ comode dato che viene risparmiato molto
codice.

9.5

Generatori Standalone

Gli iteratori standalone vengono utilizzati quando lâ€™iteratore eÌ€ slegato dal contenitore e si vuole un iteratore
che permetta di iterare su un range di interi, da start a end con un numero di passi pari a step. Un altro
esempio eÌ€ un iteratore che fa lâ€™avvolgimento (wrap) di un altro iteratore, come un iteratore che itera sui
numeri primi prendendo un iteratore che itera sui numeri.

27

9.6

Caching

In alcuni casi il contenitore non eÌ€ facile da osservare e in hasNext lâ€™unico modo per sapere se esiste
lâ€™elemento successivo eÌ€ produrre proprio next (se non giaÌ€ esistente). Nel next si richiama hasNext e
restituisce lâ€™elemento. In questo caso eÌ€ hasNext che modifica lo stato del generatore quindi eÌ€ conveniente
utilizzare un meccanismo di caching che permette di ricordare gli elementi.

28

10

EreditarietaÌ€

Lâ€™ereditarietaÌ€ consente di introdurre dei sottotipi in una gerarchia. La scrittura S â‰º T indica che S eÌ€
sottotipo di T. EÌ€ importante sottolineare che per il LSP eÌ€ possibile sostituire ad ogni istanza di T il
sottotipo S. PercheÌ€ viene introdotta?
1. Specializzare il comportamento, quando eÌ€ necessario rappresentare comportamenti diversi ma con una
certa logica comune
2. Estendere il comportamento, aggiungendo ulteriori metodi
3. Per contenere diverse implementazioni, ad esempio puoÌ€ essere necessario avere dei polinomi e dei
sottotipi per la rappresentazione densa e sparsa
4. Ricalcare una disposizione della realtaÌ€ ontologica, quando un elemento eÌ€ dentro ad un altro come nella
gerarchia delle eccezioni.
Come funziona la gerarchia in Java? Gli assegnamenti e i passaggi di parametro alla funzione sono
tali per cui, per qualsiasi assegnamento di T eÌ€ possibile passare come parametro qualsiasi istanza che sia
sottotipo di T. Il controllo dei tipi viene eseguito:
1. In fase di compilazione viene controllato il tipo apparente, cioeÌ€ il tipo dichiarato nel codice sorgente.
EÌ€ il tipo che il compilatore si aspetta che abbiano i riferimenti attribuiti ad una certa variabile â†’
Number n = new Double(3);
2. In fase di esecuzione viene controllato il tipo concreto. PuoÌ€ essere determinato solamente a runtime
dato che il compilatore non puoÌ€ prevedere che cosa lâ€™utente vada ad inserire. Ad esempio in number
n ci potrebbe essere un double, un integer, un number, ecc...

10.1

Dispatching

Quando viene chiamata una funzione x.f(e0, e1,...) non sempre eÌ€ facile capire quale deve essere il
codice da eseguire percheÌ€ ci potrebbero essere metodi con lo stesso nome e gli stessi argomenti in piuÌ€ punti
della gerarchia. Java utilizza:
â€¢ La determinazione a compile time di quale sia il tipo apparente di x e poi verifica se nel tipo apparente
di x o in uno dei sui supertipi esiste il metodo f. Infine determina la segnatura corretta con il tipo
piuÌ€ specifico.
â€¢ A runtime eÌ€ necessario determinare il metodo corretto da invocare dato che ci possono essere piuÌ€
metodi nei supertipi. Avviene quindi il dispatching, ossia viene scelto quale eÌ€ il codice da eseguire
sul tipo concreto.

10.2

Come si implementano i tipi nella gerarchia?

Il supertipo potrebbe avere implementazioni molto diverse rispetto ai sottotipi:
1. Interfaccia (supertipo di grado 0): una collezione di metodi con le relative segnature che non contengono nessuna implementazione, non ha nessuna rappresentazione, nessun attributo, nessun codice
e solo metodi pubblici. Lo scopo eÌ€ quello di esibire una base comune di comportamenti. Ad esempio,
in un supertipo che rappresenta lâ€™area delle figure geometriche potrei avere un metodo che calcola
lâ€™area e nei sottotipi implementare questo metodo con la formula corretta per quella specifica figura
geometrica. Non puoÌ€ essere instanziata. Non contengono nessun codice ma implementano il supertipo.
2. Classe astratta: alcuni metodi contengono il codice mentre altri metodi specificano solamente un
contratto come le interfacce. Una classe astratta puoÌ€ avere un metodo astratto, che non sono implementati nel supertipo e devono essere specificati in un sottotipo. Non hanno oggetti e hanno costruttori
che le sottoclassi possono chiamare, a differenza dellâ€™utente che non puoÌ€ invece falro.

29

3. Classe concreta: eÌ€ lâ€™opposto dellâ€™interfaccia, eÌ€ raccolta di metodi e di attributi che realizzano completamente un certo insieme di comportamenti, puoÌ€ essere istanziata con una new.
La reazione di sottotipo eÌ€ realizzata da una:
â€¢ Estensione: le classi astratte e concrete estendono i loro supertipi â†’ extends
â€¢ Implementazione: i sottotipi delle classi implementano le interfacce â†’ implements
280
281
282

class C {...}
abstract class A {...}
interface I {...}

283
284
285
286

class S extends C {...}
class S extends A {...}
class S implements I {...}

Nelle graffe ci sono:
Metodi
â€¢ Statici che sono legati alla classe e non allâ€™istanza
â€¢ Di istanza: possono essere â€nuoviâ€, ossia non presenti nel supertipo, oppure ereditati dal supertipo
(quindi il loro codice eÌ€ in T e non in S). I metodi sovrascritti sono giaÌ€ presenti in T ma eÌ€ necessario
riscriverli dato che S deve specializzare il comportamento.
â€¢ Metodi final che sono in T e non possono essere riscritti in S.
Attributi
â€¢ statici, non vengono ereditati dalla superclasse
â€¢ Ereditati, permettono di accedere ai membri di T
â€¢ Nuovi

10.3

IR e AF nella gerarchia

EÌ€ sempre necessario considerare la funzione di astrazione e lâ€™invariante di rappresentazione quando si parla
di implementazione.
IR deve riguardare i nuovi attriuti ed eventualmente rifarsi allâ€™invariante del genitore. IR tipicamente eÌ€ una
congiunzione tra le proprietaÌ€ dello stato della sottoclasse unito con le proprietaÌ€ dello stato della superclasse.
Ad esempio repOk prima chiama repOk del padre.
Il principio di sostituzione deve sempre valere, quindi la funzione di astrazione deve rimanere sostanzialmente
invariata.
10.3.1

Esempio

Vorrei creare un sottotipo di IntSet che restituisca il massimo â†’ MaxIntSet. EÌ€ necessario introdurre
un attributo bigger nella sottoclasse per memorizzare il massimo, che eÌ€ da aggiornare per ogni elemento
aggiunto o rimosso. I metodi mutazionali potrebbero infatti modificare questo attributo. Nel sottotipo posso
utilizzare super() per riferirsi al supertipo immediato.

30

11

Sottotipi

Se creiamo dei sottotipi eÌ€ necessario fare alcune considerazioni:
1. LSP: Il tipo concreto puoÌ€ sempre essere quello di un supertipo
2. Regola delle segnature: Per ogni metodo nel supertipo eÌ€ necessario avere un metodo con la stessa
segnatura del sottotipo. Essendo peroÌ€ il sottotipo piuÌ€ specifico potrebbe anche avere un valore restituito
piuÌ€ specifico.
3. Regola dei metodi: Ciascun metodo nel sottotipo deve comportarsi come nel supertipo.
4. Regola delle proprietaÌ€: Se delle proprietaÌ€ valgono nel supertipo devono valere anche nel sottotipo

11.1

Regola dei metodi e specificazioni

â€¢ Il sottotipo potrebbe indebolire le precondizioni e potrebbe accettare piuÌ€ input rispetto al supertipo
(rilasso le precondizioni del supertipo): P REsuper â‡’ P REsub . Se le precondizioni del supertipo sono
vere devono essere vere anche quelle del sottotipo. Le precondizioni del sottotipo includono quelle del
supertipo.
â€¢ Il sottotipo potrebbe rafforzare le postcondizioni, gli oggetti del sottotipo devo essere compatibili
anche con il supertipo: P REsuper âˆ§ P OSTsub â‡’ P OSTsuper

12

Polimorfismo

1. Polimorfismo per sottotipo: le espressioni hanno piuÌ€ forme grazie ai tipi concreti e ai tipi apparenti.
Un esempio sono le List ed ArrayList. In questo modo una singola astrazione puoÌ€ lavorare con piuÌ€
tipi.
2. Polimorfismo ad hoc: realizzato grazie a overload (1) che permette di dare una forma o comportamento
piuÌ€ specifici andando a cambiare il tipo di argomento e allâ€™overriding(2) che permette di definire
comportamenti diversi.
3. Polimorfismo parametrico: realizzato con i generici

13

Generici

13.1

Collezioni

Famiglie di strutture dati + algoritmi che sono di comoditaÌ€ generale nella programmazione, come List,
Set, Map.

13.2

Interfacce

Una interfaccia definisce solamente un tipo e contiene solamente metodi astratti senza nessuna implementazione. Tutte le classi astratte sono implementate nelle classi che hanno implements nellâ€™intestazione. La
sintassi <E> indica che lâ€™interfaccia eÌ€ generica, devo indicare il tipo di oggetti contenuto nellâ€™interfaccia in
modo da permettere al compilatore di verificare a compile time se gli oggetti inseriti nella collezione sono
corretti.
Varianti di collezioni:
1. Collection: radice della gerarchia, contiene segnature ma non contiene nessuna implementazione,
che verraÌ€ invece definita nei sottotipi
2. Set: Collezione che non puoÌ€ contenere elementi duplicati

31

3. List: collezione ordinata
4. Queue:
5. Map: Contiene coppie chiave - valore

32

14

Laboratorio

Nella specifica della classe eÌ€ necessario specificare se gli oggetti sono mutabili oppure no. Quando gli effetti
collaterali modificano lâ€™oggetto attuale eÌ€ bene indicare this.
Quando viene creata una nuova classe e non viene dichiarato extends, la classe estende automaticamente
la classe Object, che eÌ€ la radice dei tipi. Tutti i figli sanno fare almeno tutto quello che sa fare il genitore
quindi toString() il comportamento viene sovrascritto e viene automaticamente richiamato il metodo
piuÌ€ specifico, ossia quello della nuova classe che stiamo creando. La sovrascrittura non avviene quando
dichiariamo dei parametri: toString(int n), in questo caso avviene un overloading. Se peroÌ€ prima
dellâ€™implementazione viene scritto @Override il compilatore si assicureraÌ€ che venga la sovrascrittura anche
se ci sono dei parametri: Non so se eÌ€ vero
287
288
289

@Override
public static String toString(int x){}
//ho dei parametri ma il compilatore effettua la sovrastrittura di toString

Se ho due metodi sovraccaricati ma con parametri con tipi diversi il dispatcher da prioritaÌ€ al tipo che
gli passo. Ad esempio elements.remove(x), dove x eÌ€ un int, rimuoveraÌ€ un elemento in posizione x. Per
rimuovere invece lâ€™intero x da intset devo trasformarlo in integer elements.remove(Integer.valueOf(x))
1. Nelle specifiche devo anche indicare AF e IR. AF eÌ€ una funzione che nel dominio ha gli oggetti concreti,
nel codominio gli oggetti astratti.
2. IR eÌ€ implementato da RepOk mentre AF da toString
3. RepOk deve essere privata. Controllo RepOK allâ€™inizio di ogni metodo oppure prima di restituire un
valore nei metodi mutazionali. Quando ho un sottotipo devo prima controllare RepOk del padre:
if(!super.RepOK()) return false;
4. Integer.valueOf(x) anzicheÌ€ il parsing. Con il parsing potrebbero esserci problemi.
5. Quando in un costruttore metto super() significa che eredita il costruttore della superclasse, cioeÌ€ il
padre.
6. final indica che la varibile, una volta che eÌ€ stata inizializzata non potraÌ€ piuÌ€ cambiare
7. Devo sempre chiedermi come rappresento lâ€™oggetto. Ad esempio se sto rappresentano un numero
razionale devo chiedermi: come rappresento la frazione? Riduco ai minimi termini oppure no; scrivo
1
5
10 oppure 2 ? Il segno dove lo metto?
8. in hashCode e in equals non devo fare casting o conversioni, eÌ€ meglio operare direttamente sui
campi dellâ€™oggetto.
9. la comparazione tra variabili in virola mobile eÌ€ una pessima idea.
10. Quando implemento hashCode se ho delle variabili riferimento posso utilizzare direttamente hashCode
di quellâ€™oggetto, mentre se ho un tipo primitivo posso utilizzare la classe involucro Integer.hashCode
11. Nei metodi mutazionali e di produzione eÌ€ necessario commentare sempre la preservazione dellâ€™invariante
di rappresentazione. Per ipotesi induttiva devo considerare che gli oggetti rispettino lâ€™IR quando sto
per richiamare un metodo
12. il metodo o.remove() in una arraylist non diminuisce la lunghezza, ma rimane sempre la stessa.
13. Nei metodi non mutazionali non devo indicare gli effetti collaterali

33

15

Metodi utili

1. Iterare sulle chiavi di una mappa: costrusico un iteratore che itera sul set delle chiavi:
final List<Giocattolo> giocattoli = new ArrayList<>(inventario.keySet());

290

2. Stampare coda con moduli
for (i = 0; i < size() - 1; i++) r += elements[(head + i) % elements.length] +
", ";
r += elements[(head + i) % elements.length];

291

292

3. Leggere da Stdin
Scanner input = new Scanner(System.in);
while (input.hasNext()){
String line = input.nextLine();
String tkns[] = line.split(" ");
}
input.close();

293
294
295
296
297
298

4. Lunghezza di una lista
public int size (){
if (isEmpty()) return 0;
if (isFull()) return els.length;
return (tail - head + els.length) % els.length;

299
300
301
302
303

}

5. String.valueOf(n).length(): restituisce la lunghezza dellâ€™array n
6. Objects.requireNonNull controlla che il riferimento non sia null e lancia automaticamente una
eccezione NullPointerException: Objects.requireNonNull(k, "k must be not null");
7. Calcolare MCM:
private int gdc(int a, int b){
if (a<0 || b < 0) throw new IllegalArgumentException("A e B devono essere
> 0");
while (b!=0){
int tmp = b;
b = a % b;
a = tmp;
}
return a;

304
305

306
307
308
309
310
311
312

}

8. istanceof per controllare che Object o sia effettivamente unâ€™istanza di questa classe:
313
314
315

if (!(o instanceof SimpleMap)) return false;
//se mi sono accertato che sia unâ€™istanza il casting diventa lecito
SimpleMap other = (SimpleMap) o;

9. Iterare una mappa
316
317
318

for (Map.Entry<Giocattolo, Integer> entry : items.entrySet())
//come fa getKey a prendere il toString di giocattolo?
str = str + entry.getValue() + " " + entry.getKey() + "\n";

34

10. Iteratore e hashcode:
@Override
public int hashCode(){
int result = 17;
//devo fare lâ€™iteratore e mettere tutto in un array ordinato
List<Integer> inorder = new ArrayList<>();
Iterator<Integer> g = iterator();
while (g.hasNext())
inorder.add(g.next());
Collections.sort(inorder);
for (int i = 0; i<this.els.size(); i++)
result = result * 31 + Integer.hashCode(inorder.get(i));
return result;
}

319
320
321
322
323
324
325
326
327
328
329
330
331
332

@Override
public Iterator<Integer> iterator() {
return els.iterator();
}

333
334
335
336

15.1

Esercitazione 6

Figure 4: Virtual Machine
Rappresento con delle classi:
â€¢ Memoria
â€¢ Istruzioni
â€¢ Tipi di istruzioni

35

â€¢ VM
â€¢ Registri
Le informazioni del OPCODE e della modalitaÌ€ di accesso eÌ€ possibile rappresentarle con delle costanti, in
particolare dei tipi enum. Enum eÌ€ un particolare tipo di Java che permette di definire collezioni di costanti,
in modo da potermi riferire alle istanze di questa classe facendo mode.POSITION.
Come definisco lâ€™istruzione? Le istruzioni possono essere in esecuzione (exec) oppure arrestate
(isHalting). Per definire questi comportamenti comuni utilizzo delle interfacce. A seconda del tipo di
operazione si dovraÌ€ lavorare sui registri e/o sulla memoria. Noto che quando opero sui registri opero anche
sulla memoria.

I parametri devono essere salvati da qualche parte â†’ uso una classe per rappresentare ParametersBased
Instruction.
In ParametersAndRegistersBased Instructions devo utilizzare i registri.
Le ControlFlowInstruction comprendono le istruzioni di JUmpNotZero e JumpIfZero. Le uniche
classi concrete sono quelle sottolineate.

36

15.1.1

Memoria

Le celle sono rappresentate con un attributo. Deve dare la possibilitaÌ€ di leggere get () e scrivere set().
La memoria al suo interno ha la capacitaÌ€ di fornire delle locazioni di memoria pronte allâ€™uso, sulle quali le
istruzioni possano fare direttamente read e write.
15.1.2

Registri

Attributi: IP e RBP
15.1.3

VM

Registri e la memoria, cioeÌ€ i punti precedenti, e un comando run() che la faccia partire.
15.1.4

ModalitaÌ€ di accesso

Tipo numerativo
15.1.5

Opcode

Ciascun opcode deve costruire qualcosa. Li rappresento ancora come enum, come attributi hanno il codice
operativo e il numero di parametri.

37

